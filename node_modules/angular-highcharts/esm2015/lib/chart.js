/**
 * @fileoverview added by tsickle
 * Generated from: lib/chart.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as Highcharts from 'highcharts';
import { AsyncSubject } from 'rxjs';
export class Chart {
    /**
     * @param {?=} options
     */
    constructor(options = { series: [] }) {
        this.options = options;
        this.refSubject = new AsyncSubject();
        this.ref$ = this.refSubject.asObservable();
    }
    /**
     * Add Point
     * @param {?} point         Highcharts.DataPoint, number touple or number
     * @param {?=} serieIndex    Index position of series. This defaults to 0.
     * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
     * @param {?=} shift         Shift point to the start of series. This defaults to false.
     * @return {?}
     */
    addPoint(point, serieIndex = 0, redraw = true, shift = false) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > serieIndex) {
                chart.series[serieIndex].addPoint(point, redraw, shift);
            }
        }));
    }
    /**
     * Add Series
     * @param {?} series        Series Configuration
     * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
     * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
     * @return {?}
     */
    addSeries(series, redraw = true, animation) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            chart.addSeries(series, redraw, animation);
        }));
    }
    /**
     * Remove Point
     * @param {?} pointIndex    Index of Point
     * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
     * @return {?}
     */
    removePoint(pointIndex, serieIndex = 0) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > serieIndex && chart.series[serieIndex].data.length > pointIndex) {
                chart.series[serieIndex].removePoint(pointIndex, true);
            }
        }));
    }
    /**
     * Remove Series
     * @param {?} seriesIndex    Index position of series to remove.
     * @return {?}
     */
    removeSeries(seriesIndex) {
        this.ref$.subscribe((/**
         * @param {?} chart
         * @return {?}
         */
        chart => {
            if (chart.series.length > seriesIndex) {
                chart.series[seriesIndex].remove(true);
            }
        }));
    }
    /**
     * @param {?} el
     * @return {?}
     */
    init(el) {
        if (!this.ref) {
            Highcharts.chart(el.nativeElement, this.options, (/**
             * @param {?} chart
             * @return {?}
             */
            chart => {
                if (!this.ref) { // TODO: workaround for doubled callbacks on exporting charts: issue #238
                    this.refSubject.next(chart);
                    this.ref = chart;
                    this.refSubject.complete();
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.ref) {
            this.options = this.ref.options;
            this.ref.destroy();
            this.ref = undefined;
            // new init subject
            this.refSubject = new AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    Chart.prototype.refSubject;
    /** @type {?} */
    Chart.prototype.ref$;
    /** @type {?} */
    Chart.prototype.ref;
    /**
     * @type {?}
     * @private
     */
    Chart.prototype.options;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1oaWdoY2hhcnRzL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9jaGFydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sS0FBSyxVQUFVLE1BQU0sWUFBWSxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxZQUFZLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFjaEQsTUFBTSxPQUFPLEtBQUs7Ozs7SUFLaEIsWUFBb0IsVUFBOEIsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFO1FBQTVDLFlBQU8sR0FBUCxPQUFPLENBQXFDO1FBSnhELGVBQVUsR0FBbUMsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUN4RSxTQUFJLEdBQWlDLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLENBQUM7SUFHRCxDQUFDOzs7Ozs7Ozs7SUFTcEUsUUFBUSxDQUFDLEtBQVksRUFBRSxhQUFxQixDQUFDLEVBQUUsU0FBa0IsSUFBSSxFQUFFLFFBQWlCLEtBQUs7UUFDM0YsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTOzs7O1FBQUMsS0FBSyxDQUFDLEVBQUU7WUFDMUIsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxVQUFVLEVBQUU7Z0JBQ3BDLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDekQ7UUFDSCxDQUFDLEVBQUMsQ0FBQztJQUNMLENBQUM7Ozs7Ozs7O0lBUUQsU0FBUyxDQUFDLE1BQW9DLEVBQUUsTUFBTSxHQUFHLElBQUksRUFBRSxTQUFrQjtRQUMvRSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVM7Ozs7UUFBQyxLQUFLLENBQUMsRUFBRTtZQUMxQixLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDN0MsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7Ozs7O0lBT0QsV0FBVyxDQUFDLFVBQWtCLEVBQUUsVUFBVSxHQUFHLENBQUM7UUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTOzs7O1FBQUMsS0FBSyxDQUFDLEVBQUU7WUFDMUIsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxVQUFVLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLFVBQVUsRUFBRTtnQkFDekYsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ3hEO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7Ozs7SUFNRCxZQUFZLENBQUMsV0FBbUI7UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTOzs7O1FBQUMsS0FBSyxDQUFDLEVBQUU7WUFDMUIsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxXQUFXLEVBQUU7Z0JBQ3JDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3hDO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7OztJQUVELElBQUksQ0FBQyxFQUFjO1FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ2IsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxPQUFPOzs7O1lBQUUsS0FBSyxDQUFDLEVBQUU7Z0JBQ3ZELElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUUseUVBQXlFO29CQUN4RixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDNUIsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUM7b0JBQ2pCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7aUJBQzVCO1lBQ0gsQ0FBQyxFQUFDLENBQUM7U0FDSjtJQUNILENBQUM7Ozs7SUFFRCxPQUFPO1FBQ0wsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1osSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQztZQUNoQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDO1lBRXJCLG1CQUFtQjtZQUNuQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7WUFDckMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxDQUFDO1NBQzVDO0lBQ0gsQ0FBQztDQUNGOzs7Ozs7SUFqRkMsMkJBQXdFOztJQUN4RSxxQkFBb0U7O0lBQ3BFLG9CQUFzQjs7Ozs7SUFFVix3QkFBb0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBIaWdoY2hhcnRzIGZyb20gJ2hpZ2hjaGFydHMnO1xuaW1wb3J0IHsgQXN5bmNTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBGZWxpeCBJdHplbnBsaXR6LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2Vib3IvYW5ndWxhci1oaWdoY2hhcnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIEBhdXRob3IgRmVsaXggSXR6ZW5wbGl0elxuICogQGF1dGhvciBUaW1vdGh5IEEuIFBlcmV6IChjb250cmlidXRvcilcbiAqL1xuZXhwb3J0IHR5cGUgUG9pbnQgPSBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHwgSGlnaGNoYXJ0cy5Qb2ludDtcblxuZXhwb3J0IGNsYXNzIENoYXJ0IHtcbiAgcHJpdmF0ZSByZWZTdWJqZWN0OiBBc3luY1N1YmplY3Q8SGlnaGNoYXJ0cy5DaGFydD4gPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gIHJlZiQ6IE9ic2VydmFibGU8SGlnaGNoYXJ0cy5DaGFydD4gPSB0aGlzLnJlZlN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gIHJlZjogSGlnaGNoYXJ0cy5DaGFydDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wdGlvbnM6IEhpZ2hjaGFydHMuT3B0aW9ucyA9IHsgc2VyaWVzOiBbXSB9KSB7fVxuXG4gIC8qKlxuICAgKiBBZGQgUG9pbnRcbiAgICogQHBhcmFtIHBvaW50ICAgICAgICAgSGlnaGNoYXJ0cy5EYXRhUG9pbnQsIG51bWJlciB0b3VwbGUgb3IgbnVtYmVyXG4gICAqIEBwYXJhbSBzZXJpZUluZGV4ICAgIEluZGV4IHBvc2l0aW9uIG9mIHNlcmllcy4gVGhpcyBkZWZhdWx0cyB0byAwLlxuICAgKiBAcGFyYW0gcmVkcmF3ICAgICAgICBGbGFnIHdoZXRoZXIgb3Igbm90IHRvIHJlZHJhdyBwb2ludC4gVGhpcyBkZWZhdWx0cyB0byB0cnVlLlxuICAgKiBAcGFyYW0gc2hpZnQgICAgICAgICBTaGlmdCBwb2ludCB0byB0aGUgc3RhcnQgb2Ygc2VyaWVzLiBUaGlzIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgYWRkUG9pbnQocG9pbnQ6IFBvaW50LCBzZXJpZUluZGV4OiBudW1iZXIgPSAwLCByZWRyYXc6IGJvb2xlYW4gPSB0cnVlLCBzaGlmdDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgdGhpcy5yZWYkLnN1YnNjcmliZShjaGFydCA9PiB7XG4gICAgICBpZiAoY2hhcnQuc2VyaWVzLmxlbmd0aCA+IHNlcmllSW5kZXgpIHtcbiAgICAgICAgY2hhcnQuc2VyaWVzW3NlcmllSW5kZXhdLmFkZFBvaW50KHBvaW50LCByZWRyYXcsIHNoaWZ0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgU2VyaWVzXG4gICAqIEBwYXJhbSBzZXJpZXMgICAgICAgIFNlcmllcyBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSByZWRyYXcgICAgICAgIEZsYWcgd2hldGhlciBvciBub3QgdG8gcmVkcmF3IHNlcmllcy4gVGhpcyBkZWZhdWx0cyB0byB0cnVlLlxuICAgKiBAcGFyYW0gYW5pbWF0aW9uICAgICBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb24uIFRoaXMgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqL1xuICBhZGRTZXJpZXMoc2VyaWVzOiBIaWdoY2hhcnRzLlNlcmllc09wdGlvbnNUeXBlLCByZWRyYXcgPSB0cnVlLCBhbmltYXRpb246IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLnJlZiQuc3Vic2NyaWJlKGNoYXJ0ID0+IHtcbiAgICAgIGNoYXJ0LmFkZFNlcmllcyhzZXJpZXMsIHJlZHJhdywgYW5pbWF0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgUG9pbnRcbiAgICogQHBhcmFtIHBvaW50SW5kZXggICAgSW5kZXggb2YgUG9pbnRcbiAgICogQHBhcmFtIHNlcmllSW5kZXggICAgU3BlY2lmaWVkIEluZGV4IG9mIFNlcmllcy4gRGVmYXVsdHMgdG8gMC5cbiAgICovXG4gIHJlbW92ZVBvaW50KHBvaW50SW5kZXg6IG51bWJlciwgc2VyaWVJbmRleCA9IDApOiB2b2lkIHtcbiAgICB0aGlzLnJlZiQuc3Vic2NyaWJlKGNoYXJ0ID0+IHtcbiAgICAgIGlmIChjaGFydC5zZXJpZXMubGVuZ3RoID4gc2VyaWVJbmRleCAmJiBjaGFydC5zZXJpZXNbc2VyaWVJbmRleF0uZGF0YS5sZW5ndGggPiBwb2ludEluZGV4KSB7XG4gICAgICAgIGNoYXJ0LnNlcmllc1tzZXJpZUluZGV4XS5yZW1vdmVQb2ludChwb2ludEluZGV4LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgU2VyaWVzXG4gICAqIEBwYXJhbSBzZXJpZXNJbmRleCAgICBJbmRleCBwb3NpdGlvbiBvZiBzZXJpZXMgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlU2VyaWVzKHNlcmllc0luZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJlZiQuc3Vic2NyaWJlKGNoYXJ0ID0+IHtcbiAgICAgIGlmIChjaGFydC5zZXJpZXMubGVuZ3RoID4gc2VyaWVzSW5kZXgpIHtcbiAgICAgICAgY2hhcnQuc2VyaWVzW3Nlcmllc0luZGV4XS5yZW1vdmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpbml0KGVsOiBFbGVtZW50UmVmKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnJlZikge1xuICAgICAgSGlnaGNoYXJ0cy5jaGFydChlbC5uYXRpdmVFbGVtZW50LCB0aGlzLm9wdGlvbnMsIGNoYXJ0ID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZikgeyAvLyBUT0RPOiB3b3JrYXJvdW5kIGZvciBkb3VibGVkIGNhbGxiYWNrcyBvbiBleHBvcnRpbmcgY2hhcnRzOiBpc3N1ZSAjMjM4XG4gICAgICAgICAgdGhpcy5yZWZTdWJqZWN0Lm5leHQoY2hhcnQpO1xuICAgICAgICAgIHRoaXMucmVmID0gY2hhcnQ7XG4gICAgICAgICAgdGhpcy5yZWZTdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnJlZi5vcHRpb25zO1xuICAgICAgdGhpcy5yZWYuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZWYgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIG5ldyBpbml0IHN1YmplY3RcbiAgICAgIHRoaXMucmVmU3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3QoKTtcbiAgICAgIHRoaXMucmVmJCA9IHRoaXMucmVmU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==